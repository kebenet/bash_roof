# [tput cup totorial]: https://linuxcommand.org/lc3_adv_tput.php



## SESSION [column & row]
	2 to 4 file in session
	advance 2 to 3 row file view
	toggle on [group] and toggle [view file]
# 	session with [line bookmark]

# session with [RELATED: Symbol]
[related session]: fast_get_code
- gather related code!
- file & [line or symbol]

# Session folders
- ls multiple folder or find
- same like paths env where can search automatic










## refactor
# Single Refactor
# multiple step refactor
- like quickfixed but fixed in list
# - refactor [path in code] from [filename]:

# Undo each step

# refactor [step]?
- pattern => rg result => > tofile result 
		  => > to undofile [index]
		   replacement

# refactor - [rename path] [rename env variable]
-	rename env variable
-	rename path variable
-	find [unused] variable

















# Find Code multiple strategy
more fast access [file folder] 
more easy [PATH handling]


# find code by [projects folder] detect
- open file subl then goto symbol

## find reused code [line by line]
# use [FZF] for more options















# create [script managements]
- chmode
- alias for testing
- path runner
# Create [Config, Jump, Pattern]

# toogle jumping [directory], [project]

# Jump By Number: DONE :)









# TODO append to complete
- find => collect => remove from line => append to Complete.ttfile



















# [Recent]
- recent PWDPROJECT
- recent config
- recent file session
- recent toggle dir
- recent [working]


# Que Next session

# workque open recent QUE












# PATH CENTRAL: [Var|Path]
Markdown with symbols

## lsp in terminal ?

change variables from ttpattern to json var
but use sublime python as variable holder
use tmpfs shared memory, to store public variables

"/dev/shm/TT_VARS" => direct bash?



close all but not for untitle?









## DEBUGS [session] => [printing]

When  used  with [[, the < and > operators sort lexicographically using
       the current locale.  The test command sorts using ASCII ordering.

-a file
      True if file exists.
-b file
      True if file exists and is a block special file.
-c file
      True if file exists and is a character special file.
-d file
      True if file exists and is a directory.
-e file
      True if file exists.
-f file
      True if file exists and is a regular file.
-g file
      True if file exists and is set-group-id.
-h file
      True if file exists and is a symbolic link.
-k file
      True if file exists and its `sticky` bit is set.
-p file
      True if file exists and is a named pipe (FIFO).
-r file
      True if file exists and is readable.
-s file
      True if file exists and has a size greater than zero.
-t fd  
	True if file descriptor fd is open and refers to a terminal.
-u file
      True if file exists and its set-user-id bit is set.
-w file
      True if file exists and is writable.
-x file
      True if file exists and is executable.
-G file
      True if file exists and is owned by the effective group id.
-L file
      True if file exists and is a symbolic link.
-N file
      True if file exists and has been  modified  since  it  was  last
      read.
-O file
      True if file exists and is owned by the effective user id.
-S file
      True if file exists and is a socket.
file1 -ef file2
      True  if file1 and file2 refer to the same device and inode num‚Äê
      bers.
file1 -nt file2
      True if file1 is newer (according  to  modification  date)  than
      file2, or if file1 exists and file2 does not.
file1 -ot file2
      True  if file1 is older than file2, or if file2 exists and file1
      does not.