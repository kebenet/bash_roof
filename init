#!/bin/bash
#FILE! Initialize startup functions


hpp(){	# display help info
	item=$(which "$1")
	rg '^fn_[a-z]+' "${item}" -N \
	| sd '(\(\)\s*\{?)|(fn_)' '' | column -t -s $'\t'
}


sub(){

	#TODO! create sub recent files- done
	item=$(fdls | fuzzy one "${1}")

	item=$(realpath "${item}")

	if ! _check_file_size "$item"; then
		return 7
	fi

	st open "$item"
	varm append_relative "${item}"

}


copy(){	# copy file path to clip

    if [ "$#" -eq 1 ]; then

        message "TTFCLIP: name of fclip"
        return
    fi

	item="$(fdls | fzy)"

	_fclip "$item"

	message "$item : Copy to CLIP"

}

paste(){	# paste file to clipboard

	if [ ! -f "$TTFCLIP" ]; then
		message "FILE ERROR!: not a file or empty"
		return 7
	fi

	read -rp "Continue (y/n)? " answer; if [[ $answer = "" ]]; then return 7; fi

	cp "$TTFCLIP" "$PWD"

	base=$(basename "$TTFCLIP")
	message "${base}: DONE Copy to"
	message "$PWD : ."
}

_fclip() {
	#CODE! press . to empty fclip
	
	if [[ "$1" == "." ]]; then
		unset TTFCLIP
		message "EMPTY: the clipboard"
		return
	fi

	#CODE! store the directory path to TT fclip
    TTFCLIP=$(realpath "${1}")
    export TTFCLIP

}

duplicate(){	# duplicate file

	#CODE! check if not file. [-f file] [-d dir]
	if [ ! -f "$1" ]; then
		message "FILE ERROR!: file arg to duplicate"
		return 7
	fi

	message "DUPLICATE: provide new Name"
	#CODE! read single line user input
	read -er -p "new name ${ARROW} " -i "${1}" new

	cp "${1}" "${new}"
	message "DONE!: duplicate : $new"

}


remove(){	# remove file

	item="$(fdls | fzy)"

	rm "$item"

	message "$item: Remove..."

}


stop() {	# stop at current folder

    if [ "$#" -eq 1 ]; then
        export SAVEPWD="$PWD"
        message "DONE save: ${PWD}"
    else
        if [ -z "$SAVEPWD" ]; then
            message "press: . to save current folder"
        else
            cd "$SAVEPWD" || return
        fi
    fi
}


creat_shortcut_to(){	# create shortcut to folder


	file="$1"
	dirname=$(find_all_folders)

    if [ -f "${file}" ]; then

		ln "${file}"  -f -t "${dirname}"
		echo "Done create shortcut"
		echo "At ‚ùØ ${BOLD}${dirname}"
    else

		message "ERROR!: Argument must be file"
        echo "$file"
    fi
}


newsh(){

    show_input "New name" ""

    [ -z "$new" ] && echo 'empty cancel' && return 7
    
    cp "$TT_BASH/scripts/template.sh" "$new"

    chmod 700 "$new"
    git status
    lsa

}


hp(){

	full='[-]\w,\s(--)\w+'
	simple='^\s*[-]+\w*'

	echo "-s for simple version"
	# check if $1 is -s, cmd =simple else full
	[[ $1 == "-s" ]] && regex="$simple" || regex="$full"

    data=$("${@: -1}" --help)

    item=$(echo "$data"  | rg --trim "$regex" | fzy -l 20 | rg "^[-]+" -r "")

    finditem=$(echo "$data" | rg -n -F "${item}")

    index="${finditem%%:*}"

    sed -n "${index},/^\s*-/{p}" <<< "$data"

}

rename(){

	item="$(fdls | fzy -e "${1}" | fzy -q "${1}")"
	if [ ! "${item}" ]; then
		message "CANCEL: Operation..."
		return 7
	fi

    show_input_change "New name" "${item}"
    mv "${item}" "$new"

    lsa
}

history_clean(){
	item="$HOME/.bash_history"
	awk '!seen[$0]++ && length($0) >= 3 && NF' "$item" > "$TT_TEMP"
	sort -k 1,1 "$TT_TEMP" > "$item"
}


_check_file_size(){

	maxsize=300000 # 300kb limit
	item="$1"
	filesize=$(stat -c%s "$item")
	type=$(file -b --mime-type "$item")

	if [[ ! "$type" == text/* ]]; then
		return 7
	fi

	if (( filesize > maxsize )); then
	    message "ERROR: File size is over the limit. 300kb"
	    return 7
	fi

}

