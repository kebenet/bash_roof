#!/bin/bash
#FILE! Bash Templates 

tempf="/dev/shm/tttempfiles"


.lower(){	# Convert stdin to lowercase

    tr '[:upper:]' '[:lower:]'
}

.upper(){	# Convert stdin to uppercase.

    tr '[:lower:]' '[:upper:]'
}

.title(){	# Convert stdin to titlecase.

    .lower | sed 's/\<./\u&/g' | sed "s/'[[:upper:]]/\L&\l/g"
}

.detox(){	# Make text from stdin slightly less insane

    sed 's/[^A-Za-z0-9 ]/ /g' | squeeze | sed 's/ /_/g' | .lower
}

.camel(){	# Make text from stdin camel case.

    sed 's/_/ /g' | sed 's/\<\(.\)/\U\1/g' | sed 's/ //g'
}

.snake(){	# Make text from stdin snake case

    sed 's/\([[:upper:]]\)/ \1/g' | .detox
}

.squeeze(){	# Removes leading/trailing whitespace and condenses

    local char=${1:-[[:space:]]}
    sed "s%\(${char//%/\\%}\)\+%\1%g" | .trim "$char"
}

# ==================================== TERABOTERABA

.sep(){	# Convert/Join lines into Saperator

	item=$(cat| tr '\n' "${2}")
	echo "${item%?}"

}


.trim(){	# Trim stdin space.
	awk '{$1=$1};1'
}


.pair(){	# surround 2 Pair from lines
	awk -v one="$2" -v two="$3" '{ print one $0 two }'
}

.single(){	# surround stdin by Single quote
	awk '{ print "\x27" $0 "\x27" }'
}


.double(){	# surround stdin by Double quote
	awk '{ print "\"" $0 "\"" }'
}


.head(){	# Append stdin at Head
	awk -v item="$2" '{ print item $0 }'
}


.tail(){	# Append stdin at Tail
	awk -v item="$2" '{ print $0 item }'
}

.each(){	# generate all args combine with [-] as stdin.
	shift
	while read -r line; do
		echo "${@/-*/$line}"
	done
}


.com(){	# Merge from [stdin & args] by a delimiter
	paste -d "$2" - "${tempf}"
}


.merge(){	# Merge from [stdin & args] by a delimiter

	sep="$2"
	shift 2
	paste -d "$sep" <(printf "%s\n" "${@}") -

}


.mergeawk(){	# Merge awk from [stdin & args] by a delimiter

	sep="$2"
	args=("${@:3}")

	awk -v args="${args[*]}" -v sep="$sep" 'BEGIN {
	    split(args, item);
	    ln = 1;
	}
	{
	    printf("%s%s%s\n", item[ln], sep , $0);
	    ln = (ln % length(item)) + 1;
	}'
}

.str(){	# get substring from stdin by delimiter

	while read -r line; do
		ops="$2"
		echo "${line%$ops*}"
	done

}


.lines(){	# Convert Spaces to Lines
	tr ' ' '\n'
}


.store(){	# Store to temp then print result
	tee - "$tempf"
}


.eval(){	# Eval all lines
		rargs eval "${line}"
}

.arg(){	# Take args as command and Eval all Lines
	
	while read -r line; do
		eval "$2 ${line}"
	done
}


.num(){	# print & add numbers
	awk '{ print NR ":" $0 }'
}


.range(){	# Take Range of lines from stdin
	awk -v one="$2" -v two="$3" \
	'NR >= one && NR <= two'
}

#CODE! pipe is coming bro..
if [ ! -t 0 ]; then
	".$1" "$@"
	exit
fi

".$1" "$@"
